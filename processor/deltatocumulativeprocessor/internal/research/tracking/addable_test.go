// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package atomic_test

import (
	"sync"
	"testing"

	"github.com/puzpuzpuz/xsync/v3"

	"github.com/open-telemetry/opentelemetry-collector-contrib/internal/exp/metrics/identity"
)

// Go generics use GCShape stenciling. This prevents optimizations such as
// inlinling in most cases, as of Go 1.23. To run undistorted benchmarks with
// full compiler optimizations, we perform monomorphization ourselves using
// gofmt rewrites:

//go:generate sh -c "(echo '// Code generated by $GOFILE:$GOLINE; DO NOT EDIT.\n' && grep -v // addable_test.go) | gofmt -r 'Addable -> AtomicInt64' > atomicInt64_test.go"
//go:generate sh -c "(echo '// Code generated by $GOFILE:$GOLINE; DO NOT EDIT.\n' && grep -v // addable_test.go) | gofmt -r 'Addable -> MutexInt64' > mutexInt64_test.go"

//nolint:govet,unused // ids shadow is on purpose
func (Addable) benchmark(b *testing.B) {
	type T = Addable

	b.Run("map=std+prealloc", func(b *testing.B) {
		ids := makeids(b.N)
		m := make(map[identity.Stream]*T, len(ids))
		for _, id := range ids {
			m[id] = new(T)
		}

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			for i := 0; pb.Next(); i++ {
				ids := ids[:max(1, i/10)]
				id := ids[i%len(ids)]
				dp := int64(i)

				ptr := m[id]
				ptr.Add(dp)
			}
		})
	})

	b.Run("map=std+global", func(b *testing.B) {
		ids := makeids(b.N)
		var mtx sync.Mutex
		m := make(map[identity.Stream]*T)

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			mtx.Lock()
			for i := 0; pb.Next(); i++ {
				ids := ids[:max(1, i/10)]
				id := ids[i%len(ids)]
				dp := int64(i)

				ptr, ok := m[id]
				if !ok {
					ptr = new(T)
					m[id] = ptr
				}
				ptr.Add(dp)
			}
			mtx.Unlock()
		})
	})

	b.Run("map=std+RWMutex", func(b *testing.B) {
		ids := makeids(b.N)
		var mtx sync.RWMutex
		m := make(map[identity.Stream]*T)

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			for i := 0; pb.Next(); i++ {
				ids := ids[:max(1, i/10)]
				id := ids[i%len(ids)]
				dp := int64(i)

				mtx.RLock()
				ptr, ok := m[id]
				mtx.RUnlock()
				if !ok {
					mtx.Lock()
					ptr, ok = m[id]
					if !ok {
						ptr = new(T)
						m[id] = ptr
					}
					mtx.Unlock()
				}

				ptr.Add(dp)
			}
		})
	})

	b.Run("map=sync.Map", func(b *testing.B) {
		ids := makeids(b.N)
		var m sync.Map

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			zero := new(T)
			for i := 0; pb.Next(); i++ {
				ids := ids[:max(1, i/10)]
				id := ids[i%len(ids)]
				dp := int64(i)

				ptr, loaded := m.LoadOrStore(id, zero)
				if !loaded {
					zero = new(T)
				}
				ptr.(*T).Add(dp)
			}
		})
	})

	b.Run("map=xsync.MapOf", func(b *testing.B) {
		ids := makeids(b.N)
		m := xsync.NewMapOf[identity.Stream, *T]()

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			zero := new(T)
			for i := 0; pb.Next(); i++ {
				ids := ids[:max(1, i/10)]
				id := ids[i%len(ids)]
				dp := int64(i)

				ptr, loaded := m.LoadOrStore(id, zero)
				if !loaded {
					zero = new(T)
				}
				ptr.Add(dp)
			}
		})
	})
}
