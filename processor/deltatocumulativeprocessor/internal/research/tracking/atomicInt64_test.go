// Code generated by addable_test.go:17; DO NOT EDIT.

package atomic_test

import (
	"sync"
	"testing"

	"github.com/puzpuzpuz/xsync/v3"

	"github.com/open-telemetry/opentelemetry-collector-contrib/internal/exp/metrics/identity"
)

func (AtomicInt64) benchmark(b *testing.B) {
	type T = AtomicInt64

	b.Run("map=std+prealloc", func(b *testing.B) {
		ids := makeids(b.N)
		m := make(map[identity.Stream]*T, len(ids))
		for _, id := range ids {
			m[id] = new(T)
		}

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			for i := 0; pb.Next(); i++ {
				ids := ids[:max(1, i/10)]
				id := ids[i%len(ids)]
				dp := int64(i)

				ptr := m[id]
				ptr.Add(dp)
			}
		})
	})

	b.Run("map=std+global", func(b *testing.B) {
		ids := makeids(b.N)
		var mtx sync.Mutex
		m := make(map[identity.Stream]*T)

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			mtx.Lock()
			for i := 0; pb.Next(); i++ {
				ids := ids[:max(1, i/10)]
				id := ids[i%len(ids)]
				dp := int64(i)

				ptr, ok := m[id]
				if !ok {
					ptr = new(T)
					m[id] = ptr
				}
				ptr.Add(dp)
			}
			mtx.Unlock()
		})
	})

	b.Run("map=std+RWMutex", func(b *testing.B) {
		ids := makeids(b.N)
		var mtx sync.RWMutex
		m := make(map[identity.Stream]*T)

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			for i := 0; pb.Next(); i++ {
				ids := ids[:max(1, i/10)]
				id := ids[i%len(ids)]
				dp := int64(i)

				mtx.RLock()
				ptr, ok := m[id]
				mtx.RUnlock()
				if !ok {
					mtx.Lock()
					ptr, ok = m[id]
					if !ok {
						ptr = new(T)
						m[id] = ptr
					}
					mtx.Unlock()
				}

				ptr.Add(dp)
			}
		})
	})

	b.Run("map=sync.Map", func(b *testing.B) {
		ids := makeids(b.N)
		var m sync.Map

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			zero := new(T)
			for i := 0; pb.Next(); i++ {
				ids := ids[:max(1, i/10)]
				id := ids[i%len(ids)]
				dp := int64(i)

				ptr, loaded := m.LoadOrStore(id, zero)
				if !loaded {
					zero = new(T)
				}
				ptr.(*T).Add(dp)
			}
		})
	})

	b.Run("map=xsync.MapOf", func(b *testing.B) {
		ids := makeids(b.N)
		m := xsync.NewMapOf[identity.Stream, *T]()

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			zero := new(T)
			for i := 0; pb.Next(); i++ {
				ids := ids[:max(1, i/10)]
				id := ids[i%len(ids)]
				dp := int64(i)

				ptr, loaded := m.LoadOrStore(id, zero)
				if !loaded {
					zero = new(T)
				}
				ptr.Add(dp)
			}
		})
	})
}
